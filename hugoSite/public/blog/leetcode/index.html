<!DOCTYPE html>
<html>

<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
<title> Leetcode &middot; Arthur &amp; Code &amp; 42 </title>


<link rel="stylesheet" href="http://www.arthur-code-42.cc/css/slim.css">
<link rel="stylesheet" href="http://www.arthur-code-42.cc/css/highlight.min.css">
<link href='https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,700|Source+Code+Pro' rel='stylesheet' type='text/css'>

<link rel="apple-touch-icon-precomposed" sizes="144x144" href="http://www.arthur-code-42.cc/apple-touch-icon-144-precomposed.png">
<link rel="shortcut icon" href="http://www.arthur-code-42.cc/favicon.ico">


<link href="" rel="alternate" type="application/rss+xml" title="Arthur &amp; Code &amp; 42" />

  <style type="text/css">
    .post-aside-div{
      position: fixed;
      top: 100px;
      right: 0;
      width: 20%;
      -webkit-box-ordinal-group:3;
      order:2;
      box-sizing: border-box;
    }
    .post-aside{
      font-size: .875rem;
      padding-right: 1rem;
      list-style-type: none;
      list-style: none;
      color: #0594cb;
      text-decoration: none;
      border-left-style: solid;
      border-left-width: 1px;
      border-color: #ccc;
    }
    ul{
      list-style-type: none;
      padding-left: 0.8rem;
    }
    li{
      padding-left: 0.2rem;
      line-height: 1.555;
    }
    a {
      font-family: 'Source Sans Pro', 'Helvetica Neue', Helvetica, 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', 'WenQuanYi Micro Hei', Arial, Serif;

      font-weight:400;
      color: #7a7a7a;
      text-decoration: none;
    }
  </style>
</head>

<body>
  <div class="container">
    <div class="header">
  <h1 class="site-title"><a href="http://www.arthur-code-42.cc/">Arthur &amp; Code &amp; 42</a></h1>
  <p class="site-tagline">记录代码、算法、架构和一切</p>
  <div class="nav">
    <a class="nav-btn" href="#">
      <span class="ci ci-burger"></span>
    </a>
    <ul class="nav-list">
      
      <li><a href="http://www.arthur-code-42.cc/">Coding</a></li>
      
      <li><a href="http://www.arthur-code-42.cc/">Reading</a></li>
      
      <li><a href="http://www.arthur-code-42.cc/">Recording</a></li>
      
      <li><a href="http://www.arthur-code-42.cc/">Cecording</a></li>
      
      <li><a href="http://www.arthur-code-42.cc/">About</a></li>
       
	  <li class="spacer">&ac;</li>

      <li><a href="https://github.com/arthur">Github</a></li>  
    </ul>
  </div>
</div>
    <div class="content">
      <div class="post">
        <h2 class="post-title"><a href="http://www.arthur-code-42.cc/blog/leetcode/">Leetcode</a></h2>
          <div class="post-aside-div">
          <aside class="post-aside" id="TableOfContents">
            <nav id="TableOfContents">
<ul>
<li><a href="#leetcode-record">LeetCode Record</a>
<ul>
<li><a href="#初级题目">初级题目</a>
<ul>
<li><a href="#数组">数组</a>
<ul>
<li><a href="#1-从排序数组中删除重复项">1.从排序数组中删除重复项</a></li>
<li><a href="#2-旋转数组">2.旋转数组</a></li>
<li><a href="#3-存在重复">3.存在重复</a></li>
<li><a href="#4-只出现一次的数字">4.只出现一次的数字</a></li>
<li><a href="#5-两个数组的交集-ii">5.两个数组的交集 II</a></li>
<li><a href="#6-旋转图像">6.旋转图像</a></li>
<li><a href="#7-加一">7.加一</a></li>
<li><a href="#8-移动0">8.移动0</a></li>
<li><a href="#9-两数之和">9.两数之和</a></li>
<li><a href="#10-买卖股票的最佳时机-ii">10.买卖股票的最佳时机 II</a></li>
<li><a href="#11-有效的数独">11.有效的数独</a></li>
</ul></li>
<li><a href="#字符串">字符串</a>
<ul>
<li><a href="#1-反转字符串">1.反转字符串</a></li>
<li><a href="#2-颠倒整数">2.颠倒整数</a></li>
<li><a href="#3-字符串中的第一个唯一字符">3.字符串中的第一个唯一字符</a></li>
<li><a href="#4-有效的字母异位词">4.有效的字母异位词</a></li>
<li><a href="#5-验证回文字符串">5.验证回文字符串</a></li>
<li><a href="#6-字符串转整数-atoi">6.字符串转整数（atoi）</a></li>
<li><a href="#7-实现strstr">7.实现strStr()</a></li>
<li><a href="#8-最长公共前缀">8.最长公共前缀</a></li>
</ul></li>
<li><a href="#链表">链表</a>
<ul>
<li><a href="#1-删除链表的倒数第n个节点">1.删除链表的倒数第N个节点</a></li>
<li><a href="#2-反转链表">2. 反转链表</a></li>
<li><a href="#3-合并两个有序链表">3.合并两个有序链表</a></li>
<li><a href="#4">4.</a></li>
<li><a href="#5">5.</a></li>
</ul></li>
</ul></li>
</ul></li>
</ul>
</nav>
          </aside> 
          </div>
        <div class="post-content">
          <h1 id="leetcode-record">LeetCode Record</h1>

<blockquote>
<p>记录所有目前所有已经解出题目的解法及具体代码，以下代码若无具体说明均为<strong>Go</strong></p>
</blockquote>

<hr />

<p>[TOC]</p>

<h2 id="初级题目">初级题目</h2>

<h3 id="数组">数组</h3>

<h4 id="1-从排序数组中删除重复项">1.从排序数组中删除重复项</h4>

<p>给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。不要使用额外的数组空间，你必须在原地修改输入数组并在使用 $O(1)$ 额外空间的条件下完成。</p>

<p><strong>示例：</strong>
&gt;给定数组 nums = [1,1,2],
&gt;函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2
&gt; 你不需要考虑数组中超出新长度后面的元素。</p>

<p><strong>解答：</strong></p>

<pre><code class="language-go">func removeDuplicates(nums []int) int {
    if len(nums) == 0 {
        return 0
    }
    
    var l int = 0
    for i := 1; i &lt; len(nums); i++ {
        if nums[i] != nums[l] {
            l++
            nums[l] = nums[i]
        }
    }
    return l+1
}
</code></pre>

<p><strong>知识点：</strong></p>

<p>因为这个题目不需要构建出新的数组，所以只需使用<strong>原地算法</strong>进行替换元素即可。使用两个下标，一个进行逐个元素循环，另一个只有当元素不同时才前进一。
&gt;<strong>原地算法</strong>：
&gt;在计算机科学中，一个原地算法（in-place algorithm）是一种使用小的，固定数量的额外之空间来转换资料的算法。当算法执行时，输入的资料通常会被要输出的部份覆盖掉。不是原地算法有时候称为非原地（not-in-place）或不得其所（out-of-place）。</p>

<h4 id="2-旋转数组">2.旋转数组</h4>

<p>将包含 n 个元素的数组向右旋转 k 步。空间复杂度$O(1)$，且有最少三种办法
<strong>示例：</strong>
&gt;如果  n = 7 ,  k = 3，给定数组  [1,2,3,4,5,6,7]  ，向右旋转后的结果为 [5,6,7,1,2,3,4]</p>

<p><strong>解答：</strong></p>

<pre><code class="language-go">func reverse(nums []int, start int, end int) []int {
	var temp int
	for ; start &lt; end; start, end = start+1, end-1 {
		temp = nums[start]
		nums[start] = nums[end]
		nums[end] = temp
	}
	return nums
}

func rotate(nums []int, k int) {
	l := len(nums)
	if l == 0 {
		return
	}
	k = k % len(nums)
	nums = reverse(nums, 0, l-k-1)
	nums = reverse(nums, l-k, l-1)
	nums = reverse(nums, 0, l-1)
}
</code></pre>

<p><strong>知识点：</strong>
采用<strong>分治</strong>的方法，先通过k算出真正需要移动的步数k，然后对不需要越过数组长度的元素(最终下标为：l-k-1)长度内的元素调换顺序，然后在对越过数组长度的元素进行调换顺序，然后整体调换顺序。</p>

<h4 id="3-存在重复">3.存在重复</h4>

<p>给定一个整数数组，判断是否存在重复元素。
如果任何值在数组中出现至少两次，函数应该返回 true。如果每个元素都不相同，则返回 false</p>

<p><strong>示例：无</strong></p>

<p><strong>解答：</strong></p>

<pre><code class="language-go">//方法一，先排序，后使用类似原地算法的检测方式来检测是否有重复
func containsDuplicateSort(nums []int) bool {
	if len(nums) == 0 {
		return false
	}
	sort.Ints(nums)
	l := 0
	for i := 1; i &lt; len(nums); i++ {
		if nums[i] != nums[l] {
			l++
		} else {
			return true
		}
	}
	return false
}

//方法二，使用额外空间来进行检测
func containsDuplicateMemory(nums []int) bool {
	l := len(nums)
	if l == 0 {
		return false
	}
	var numsMap = make(map[int]bool, l)
	for i := 0; i &lt; l; i++ {
		if _, ok := numsMap[nums[i]]; !ok {
			numsMap[nums[i]] = true
		} else {
			return true
		}
	}
	return false
}
</code></pre>

<p><strong>知识点：</strong></p>

<h4 id="4-只出现一次的数字">4.只出现一次的数字</h4>

<p>给定一个整数数组，除了某个元素外其余元素均出现两次。请找出这个只出现一次的元素。你的算法应该是一个线性时间复杂度。 你可以不用额外空间来实现它吗？</p>

<p><strong>示例：无</strong>
<strong>解答：</strong></p>

<pre><code class="language-go">func singleNumber(nums []int) int {
	l := len(nums)
	if l == 0 {
		return 0
	}
	result := nums[0]
	for i := 1; i &lt; len(nums); i++ {
		result = result ^ nums[i]
	}
	return result 
}
</code></pre>

<p><strong>知识点：</strong>
&gt;异或运算
&gt;如果a、b两个值不相同，则异或结果为1。如果a、b两个值相同，异或结果为0。</p>

<p>题目中说明除开只有单个的元素，其余元素均为出现两次，则通过
A^B^C^A^B = A^A^B^B^C = 0 ^ 0 ^ C = C 可得出单次出现的元素</p>

<h4 id="5-两个数组的交集-ii">5.两个数组的交集 II</h4>

<p>给定两个数组，写一个方法来计算它们的交集。</p>

<p><strong>示例：</strong>
&gt;给定 nums1 = [1, 2, 2, 1], nums2 = [2, 2], 返回 [2, 2].</p>

<p>注意：
    输出结果中每个元素出现的次数，应与元素在两个数组中出现的次数一致。
    我们可以不考虑输出结果的顺序。</p>

<p>跟进:
如果给定的数组已经排好序呢？你将如何优化你的算法？
如果 nums1 的大小比 nums2 小很多，哪种方法更优？
如果nums2的元素存储在磁盘上，内存是有限的，你不能一次加载所有的元素到内存中，你该怎么办？</p>

<p><strong>解答：</strong></p>

<pre><code class="language-go">func intersect(nums1 []int, nums2 []int) []int {
	var res []int
	var countMap = make(map[int]int)
	if len(nums1) == 0 || len(nums2) == 0 {
		return res
	}
	for i := 0; i &lt; len(nums1); i++ {
		if v, ok := countMap[nums1[i]]; !ok {
			countMap[nums1[i]] = 1
		} else {
			countMap[nums1[i]] = v + 1
		}
	}

	for i := 0; i &lt; len(nums2); i++ {
		if v, ok := countMap[nums2[i]]; ok &amp;&amp; v &gt;= 1 {
			res = append(res, nums2[i])
			countMap[nums2[i]]--
		}
	}
	return res
}
</code></pre>

<p><strong>知识点：</strong>
先循环第一个数组，记录出现的元素及出现次数，记录的map A 用元素做key，value为出现次数。再循环第二个数组，当出现元素存在于第一个数组中，<strong>并且出现次数&gt;=1</strong>，则推入最终的结果记录数组，并且A中该元素为k的value自减。</p>

<p><strong>TODO：</strong>
后续思考跟进内容并给出答案
这里记录下别人的思考
&gt;1. 如果不排序，$O(mn)$。<br />
&gt;2. 如果m和n都在合理范围内，先排序，再一个一个对比，时间复杂度$O(nlgn + mlgm + m+n)$。<br />
&gt;3. 如果m远小于n, 对n排序，m也排序$O(nlgn+mlgm+m+n)$，或者m不排序$O(nlgn + mn)$。 这两种都差不多。也可以对m不排序，在n里做binary search，这样复杂度降低为nlgn+mlgn, 降很低。
&gt;4. 如果n很大，n只能存在disk上。只能把m load到内存，然后n一个一个的读进来，和m对比，这时m可以用hash存，这样复杂度就为$O(n)$了。</p>

<p><a href="https://blog.csdn.net/whl_program/article/details/71244305">引用CSDN地址</a></p>

<h4 id="6-旋转图像">6.旋转图像</h4>

<p>给定一个 n × n 的二维矩阵表示一个图像。
将图像顺时针旋转 90 度。
你必须在<strong>原地（不可使用新的空间）</strong>旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。</p>

<p><strong>示例：</strong>
&gt;给定 <strong>matrix</strong> =
&gt;[<br />
&gt;   [1,2,3],
&gt;   [4,5,6],
&gt;   [7,8,9]
&gt;],
&gt;原地旋转输入矩阵，使其变为:
&gt;[
&gt;   [7,4,1],
&gt;   [8,5,2],
&gt;   [9,6,3]
&gt;]
&gt;
&gt;给定 <strong>matrix</strong> =
&gt;[
&gt;   [ 5, 1, 9,11],
&gt;   [ 2, 4, 8,10],
&gt;   [13, 3, 6, 7],
&gt;   [15,14,12,16]
&gt;],
&gt;
&gt;原地旋转输入矩阵，使其变为:
&gt;[
&gt;   [15,13, 2, 5],
&gt;   [14, 3, 4, 1],
&gt;   [12, 6, 8, 9],
&gt;   [16, 7,10,11]
&gt;]
<strong>解答：</strong></p>

<pre><code class="language-go">func rotate(matrix [][]int)  {
    var temp int

	n := len(matrix)

	if n == 0 {
		return
	}
	for i := 0; i &lt; n; i++ {
		for j := 0; j &lt; n; j++ {
			if i &lt; j {
				temp = matrix[i][j]
				matrix[i][j] = matrix[j][i]
				matrix[j][i] = temp
			}
		}
	}
	for i := 0; i &lt; n; i++ {
		for j := 0; j &lt; n; j++ {
			if j &lt; n/2 {
				temp = matrix[i][j]
				matrix[i][j] = matrix[i][len(matrix)-j-1]
				matrix[i][len(matrix)-j-1] = temp
			}
		}
	}
}
</code></pre>

<p><strong>知识点：</strong>
&gt;   [1,2,3],
&gt;   [4,5,6],
&gt;   [7,8,9]
&gt;   先通过下标，xy的值 调换为 yx的值
&gt;  [1,4,7]
&gt;  [2,5,8]
&gt;  [,3,6,9]
&gt;  然后再行数据首尾相调换即可为
&gt;   [7,4,1],
&gt;   [8,5,2],
&gt;   [9,6,3]</p>

<h4 id="7-加一">7.加一</h4>

<p>给定一个非负整数组成的非空数组，给整数加一。
可以假设整数不包含任何前导零，除了数字0本身。
最高位数字存放在列表的首位。</p>

<p><strong>示例：无</strong>
<strong>解答：</strong></p>

<pre><code class="language-go">func plusOne(digits []int) []int {
    if len(digits) == 0 {
		return digits
	}

	for i := len(digits) - 1; i &gt;= 0; i-- {
		if digits[i] == 9 {
			digits[i] = 0
		} else {
			digits[i]++
			return digits
		}
	}
	l := len(digits)
	for i := 0; i &lt; l; i++ {
		if digits[i] != 0 {
			return digits
		}
	}
	var res = []int{1}
	res = append(res, digits...)
	return res
}
</code></pre>

<p><strong>知识点：</strong>
如果数组当前值为9，改为0并继续循环，如果不为9则直接返回数据。但是最终要检查如遇到最坏情况的话，数组中所有数据均为9时，则需要在数组头添加1后再输出</p>

<h4 id="8-移动0">8.移动0</h4>

<p>给定一个数组 nums, 编写一个函数将所有 0 移动到它的末尾，同时保持非零元素的相对顺序。
<strong>注意事项：</strong></p>

<ol>
<li>必须在原数组上操作，不要为一个新数组分配额外空间。</li>
<li>尽量减少操作总数。</li>
</ol>

<p><strong>示例：</strong>
&gt;定义 nums = [0, 1, 0, 3, 12]，调用函数之后， nums 应为 [1, 3, 12, 0, 0]。</p>

<p><strong>解答：</strong></p>

<pre><code class="language-go">func moveZeroes(nums []int)  {
    if len(nums) == 0 {
		return
	}
	var j = 0
	for i := 0; i &lt; len(nums); i++ {
		if nums[i] != 0 {
			temp := nums[j]
			nums[j] = nums[i]
			nums[i] = temp
			j++
		}
	}
}
</code></pre>

<p><strong>知识点：</strong>
两个下表，一个顺序移动，一个停留在0处，只要还有非零的数值，就交换，这样后面只会剩下0</p>

<h4 id="9-两数之和">9.两数之和</h4>

<p><strong>示例：</strong>
&gt;给定 nums = [2, 7, 11, 15], target = 9
&gt;因为 nums[0] + nums[1] = 2 + 7 = 9
&gt;所以返回 [0, 1]</p>

<p><strong>解答：</strong></p>

<pre><code class="language-go">
func twoSum(nums []int, target int) []int {
	if len(nums) == 0 {
		return nums
	}

	for i := 0; i &lt; len(nums); i++ {
		for j := 1; j &lt; len(nums); j++ {
			if target-nums[i] == nums[j] &amp;&amp; i != j {
				return []int{i, j}
			}
		}
	}
	return []int{}
}

</code></pre>

<p><strong>知识点：</strong>
1、双循环暴力解决，时间复杂度 $O({n^2})$
2、可以通过map，但golang不知道怎么解决下标不同的同一个值的问题，时间复杂度$O(n)$，可以后续想想办法
3、结合1、2、方法，将1中的$O(n^2)$  降至$O(nlgn)$</p>

<h4 id="10-买卖股票的最佳时机-ii">10.买卖股票的最佳时机 II</h4>

<p><strong>示例：无</strong>
<strong>解答：</strong></p>

<pre><code class="language-go">
</code></pre>

<p><strong>知识点：</strong></p>

<h4 id="11-有效的数独">11.有效的数独</h4>

<p><strong>示例：无</strong>
<strong>解答：</strong></p>

<pre><code class="language-go">
</code></pre>

<p><strong>知识点：</strong></p>

<h3 id="字符串">字符串</h3>

<h4 id="1-反转字符串">1.反转字符串</h4>

<p>请编写一个函数，其功能是将输入的字符串反转过来。</p>

<p><strong>示例：</strong>
&gt;输入：s = &ldquo;hello&rdquo;
&gt;返回：&rdquo;olleh&rdquo;</p>

<p><strong>解答：</strong></p>

<pre><code class="language-go">func reverseString(s string) string {
    var res = []uint8{}
	for i := len(s) - 1; i &gt;= 0; i-- {
		res = append(res, s[i])
	}
	return string(res)
}
</code></pre>

<p><strong>知识点：</strong>
字符串作为数组来理解的话，字符串其实就是一个[]uint8的数组，通过空间换时间，空间复杂度$O(n)$，时间复杂度$O(n)$</p>

<h4 id="2-颠倒整数">2.颠倒整数</h4>

<p>给定一个 32 位有符号整数，将整数中的数字进行反转。</p>

<p><strong>示例：</strong>
&gt;输入: 123
&gt;输出: 321
&gt;
&gt;输入: -123
&gt;输出: -321
&gt;
&gt;输入: 120
&gt;输出: 21</p>

<p>假设我们的环境只能存储 32 位有符号整数，其数值范围是$ [−2^{31},  2^{31} − 1]$。根据这个假设，如果反转后的整数溢出，则返回 0。</p>

<p><strong>解答：</strong></p>

<pre><code class="language-go">func reverse(x int) int {
	if x &lt; 10 &amp;&amp; x &gt; -10 {
		return x
	}
	res := 0
	for x != 0 {
		res = res*10 + x%10
		x = x / 10
	}

	if res &lt; math.MinInt32 || res &gt; math.MaxInt32 {
		return 0
	}

	return res
}
</code></pre>

<p><strong>知识点：</strong>
一个整数可以通过不停的%10 /10 来获取每一位的数据，在通过每次结果的乘10累加获取最终的翻转值</p>

<h4 id="3-字符串中的第一个唯一字符">3.字符串中的第一个唯一字符</h4>

<p>给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。</p>

<p><strong>示例：</strong>
&gt;s = &ldquo;leetcode&rdquo;
&gt;返回 0.</p>

<blockquote>
<p>s = &ldquo;loveleetcode&rdquo;,
返回 2.</p>
</blockquote>

<p><strong>解答：</strong></p>

<pre><code class="language-go">func firstUniqChar(s string) int {
	if len(s) == 0 {
		return -1
	}
	var res map[uint8]int = make(map[uint8]int)
	for i := 0; i &lt; len(s); i++ {
		if _, ok := res[s[i]]; !ok {
			res[s[i]] = 1
		} else {
			res[s[i]]++
		}
	}

	for i := 0; i &lt; len(s); i++ {
		if v, ok := res[s[i]]; v == 1 &amp;&amp; ok {
			return i
		}
	}
	return -1
}
</code></pre>

<p><strong>知识点：</strong>
1、这类查找存在不存在的均可暴力多层循环解决，但无技术含量，不进行实现了
2、本来想采用原地算法，但由于未规定特殊元素个数且需要查找的是特殊元素，而非重复元素，所以当特殊元素处于尾部或根本没特殊元素时，会检查失败，本方案抛弃
3、使用空间换时间，新建立一个数组放入字符串中每个元素且标记元素个数，循环完毕后在一次循环检查就能得出结论，方案可行且复杂度较低</p>

<h4 id="4-有效的字母异位词">4.有效的字母异位词</h4>

<p>给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的一个字母异位词。</p>

<p><strong>示例：</strong>
&gt;s = &ldquo;anagram&rdquo;，t = &ldquo;nagaram&rdquo;，返回 true
&gt;s = &ldquo;rat&rdquo;，t = &ldquo;car&rdquo;，返回 false
<strong>解答：</strong></p>

<pre><code class="language-go">func isAnagram(s string, t string) bool {
    sMap := make([]int, 26)
    tMap := make([]int, 26)
    
    for i := 0; i &lt; len(s); i++ {
        sMap[s[i]-'a']++
    }
    for i := 0; i &lt; len(t); i++ {
        tMap[t[i]-'a']++
    }
    
    for i := 0; i &lt; 26; i++ {
        if sMap[i] != tMap[i] {
            return false
        }
    }
    return true
}
</code></pre>

<p><strong>知识点：</strong>
1. 两个字符串，首先想到用两个数组来标记各个字符串中字母出现的字符及字符的个数，然后对数组进行比对，又因为字母一共只有26个，所以数组设置长度只需要26即可，最终检测循环次数为26</p>

<h4 id="5-验证回文字符串">5.验证回文字符串</h4>

<p>给定一个字符串，确定它是否是回文，只考虑字母数字字符和忽略大小写。</p>

<p><strong>示例：</strong>
&gt;&ldquo;A man, a plan, a canal: Panama&rdquo; 是回文字符串。
&gt;&ldquo;race a car&rdquo; 不是回文字符串。</p>

<p><strong>解答：</strong></p>

<pre><code class="language-go">func isPalindrome(s string) bool {
	if s == &quot;&quot; {
		return false
	}
	s = strings.ToLower(s)
	l := len(s) - 1
	for i := 0; i &lt; len(s); {
		if s[i] &lt; 'a' || s[i] &gt; 'z' {
			i++
			continue
		}
		if s[l] &lt; 'a' || s[l] &gt; 'z' {
			l--
			continue
		}
		if s[l] != s[i] &amp;&amp; l &gt;= i {
			return false
		}
		i++
		l--
	}
	return true
}
</code></pre>

<p><strong>知识点：</strong>
1、比较疑惑的是，自测通过检测，但是提交代码时，&rdquo; &ldquo; 无法通过测试…在本机实验时可以通过……比较疑惑
2、思路很简单，一个数组两个指针，分别从头部和尾部开始验证，当遇到非字母字符时跳过并指针移动即可，网上大部分思路也是如此，bu</p>

<h4 id="6-字符串转整数-atoi">6.字符串转整数（atoi）</h4>

<p>实现 atoi，将字符串转为整数。</p>

<p>在找到第一个非空字符之前，需要移除掉字符串中的空格字符。如果第一个非空字符是正号或负号，选取该符号，并将其与后面尽可能多的连续的数字组合起来，这部分字符即为整数的值。如果第一个非空字符是数字，则直接将其与之后连续的数字字符组合起来，形成整数。</p>

<p>字符串可以在形成整数的字符后面包括多余的字符，这些字符可以被忽略，它们对于函数没有影响。</p>

<p>当字符串中的第一个非空字符序列不是个有效的整数；或字符串为空；或字符串仅包含空白字符时，则不进行转换。</p>

<p>若函数不能执行有效的转换，返回 0。</p>

<p><strong>示例：</strong>
&gt;输入: &ldquo;42&rdquo;
&gt;输出: 42</p>

<blockquote>
<p>输入: &ldquo;words and 987&rdquo;
输出: 0
解释: 第一个非空字符是 &lsquo;w&rsquo;, 但它不是数字或正、负号。因此无法执行有效的转换。</p>
</blockquote>

<p><strong>解答：</strong></p>

<pre><code class="language-go">func myAtoi(str string) int {
	if len(str) == 0 {
		return 0
	}
	b := 1
	numIndex := 0
	for ; numIndex &lt; len(str); numIndex++ {
		if str[numIndex] == ' ' {
			continue
		}
		break
	}
	if numIndex+1 &gt; len(str) {
		return 0
	}
	if str[numIndex] == '-' || str[numIndex] == '+' {
		if str[numIndex] == '-' {
			b = -1
		}
		numIndex++
	}
	if numIndex+1 &gt; len(str) {
		return 0
	}
	res := 0
	for i := numIndex; i &lt; len(str); i++ {
		if str[i] &lt; '0' || str[i] &gt; '9' {
			break
		}
		res = 10*res + int(str[i]-'0')
		if b*res &gt;= math.MaxInt32 {
			return math.MaxInt32
		}

		if b*res &lt;= math.MinInt32 {
			return math.MinInt32
		}
	}
	res = res * b
	return res
}
</code></pre>

<p><strong>知识点：</strong>
思考步骤如下：
1、先去掉空格，切割字符串
2、找到符号位置，再次切割字符串
3、循环累加*10并累加当前，并且在每次累加后判断是否超出范围，如超出的话直接返回范围边界
4、不可在全部累加完成后再判断范围，因为可能会出现溢出导致数据异常，如累加数*1 变为负数</p>

<h4 id="7-实现strstr">7.实现strStr()</h4>

<p>给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  -1。</p>

<p><strong>示例：</strong>
&gt;输入: haystack = &ldquo;hello&rdquo;, needle = &ldquo;ll&rdquo;
&gt;输出: 2</p>

<p><strong>解答：</strong></p>

<pre><code class="language-go">func strStr(haystack string, needle string) int {
	hLen := len(haystack)
	nLen := len(needle)
	if nLen == 0 {
		return 0
	}
	if nLen &gt; hLen {
		return -1
	}

	for i := 0; i &lt;= hLen-nLen; i++ {
		j := 0
		for ; j &lt; nLen; j++ {
			if haystack[i+j] != needle[j] {
				break
			}
		}
		if j == nLen {
			return i
		}
	}
	return -1
}

</code></pre>

<p><strong>知识点：</strong>
1、不用将haystack全部循环，循环至(hLen-nlen)处即可，因为再往后循环的话，剩余字符串长度已经小于needle长度</p>

<h4 id="8-最长公共前缀">8.最长公共前缀</h4>

<p>编写一个函数来查找字符串数组中的最长公共前缀。</p>

<p>如果不存在公共前缀，返回空字符串 &ldquo;&ldquo;。</p>

<p><strong>示例：</strong>
&gt;输入: [&ldquo;flower&rdquo;,&ldquo;flow&rdquo;,&ldquo;flight&rdquo;]
&gt;输出: &ldquo;fl&rdquo;</p>

<blockquote>
<p>输入: [&ldquo;dog&rdquo;,&ldquo;racecar&rdquo;,&ldquo;car&rdquo;]
输出: &ldquo;&rdquo;
解释: 输入不存在公共前缀。</p>
</blockquote>

<p><strong>解答：</strong></p>

<pre><code class="language-go">
func longestCommonPrefix(strs []string) string {
	if len(strs) == 0 {
		return &quot;&quot;
	}

	if len(strs) == 1 {
		return strs[0]
	}

	for i := 0; i &lt; len(strs[0]); i++ {
		for j := 1; j &lt; len(strs); j++ {
			if len(strs[j]) &lt; i+1 || strs[j][i] != strs[0][i] {
				return strs[0][0:i]
			}
		}

	}
	return strs[0]
}
</code></pre>

<p><strong>知识点：</strong>
思路就是用第一个字符串的每一个字母和后面的字符串的同样位置进行对比，如果一直就继续，当出现不一致就跳出循环给出第一个字符串，从第一个位置开始到当前位置-1的字符串</p>

<h3 id="链表">链表</h3>

<h4 id="1-删除链表的倒数第n个节点">1.删除链表的倒数第N个节点</h4>

<p>给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。</p>

<p><strong>示例：</strong>
&gt;给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.
&gt;当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.</p>

<p><strong>解答：</strong></p>

<pre><code class="language-go"> // Definition for singly-linked list.
 // type ListNode struct {
 //     Val int
 //     Next *ListNode
 // }
func removeNthFromEnd(head *ListNode, n int) *ListNode {
    var len int
	var header = &amp;ListNode{
		Val: -1,
	}
	node := head
	for {
		len++
		if node.Next == nil {
			break
		}
		node = node.Next
	}
	header.Next = head
	res := header
	for i := 0; i &lt;= len; i++ {
		if i == len-n {
			res.Next = res.Next.Next
		} else {
			res = res.Next
		}
	}
	return header.Next
}

//网上耗时较少的一个写法
func removeNthFromEnd(head *ListNode, n int) *ListNode {
    if n == 0 {
        return head
    }
    if head == nil {
        return head
    }
    // if n == 1 &amp;&amp; head.Next == nil {
    //     return nil
    // }
    ahead := head
    current := head
    
    for n &gt; 0 &amp;&amp; ahead != nil {
        ahead = ahead.Next
        n--
    }
    
    for ahead != nil &amp;&amp; ahead.Next != nil {
        ahead = ahead.Next
        current = current.Next
    }
    if ahead == nil {
        return head.Next
    } else if current.Next == nil {
        return nil
    } else {
        current.Next = current.Next.Next
    }
    
    return head
}
</code></pre>

<p><strong>知识点：</strong>
思路：先计算出链表长度，然后从头部开始循环，到指定长度时删除链表节点。小技巧是给一个默认头部，这样哪怕是要删除给出的链表的原本头部都是可以的，不会造成报错。</p>

<p>同时贴一个网友的解法，另一个思路，耗时差别应该不特别大</p>

<h4 id="2-反转链表">2. 反转链表</h4>

<p>反转一个单链表</p>

<p><strong>示例：</strong>
&gt;输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL
&gt;输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</p>

<p><strong>进阶：</strong>
你可以迭代或递归地反转链表。你能否用两种方法解决这道题？
<strong>解答：</strong></p>

<pre><code class="language-go"> // Definition for singly-linked list.
 // type ListNode struct {
 //     Val int
 //     Next *ListNode
 // }
func reverseList(head *ListNode) *ListNode {
	if head == nil {
		return head
	}
	nodeList := &amp;ListNode{Val: head.Val, Next: nil}
	if head.Next != nil {
		head = head.Next
		for {
			tmp := &amp;ListNode{}
			tmp.Val = head.Val
			tmp.Next = nodeList
			nodeList = tmp
			if head.Next == nil {
				break
			}
			head = head.Next
		}
	}
	return nodeList
}

//耗时更少的写法
func reverseList(head *ListNode) *ListNode {
    if head == nil || head.Next == nil {
        return head
    }
    pre := head
    current := pre.Next
    pre.Next = nil
    next := head
    for current != nil {
        next = current.Next
        current.Next = pre
        pre = current
        current = next
    }
    return pre
}
</code></pre>

<p><strong>知识点：</strong></p>

<h4 id="3-合并两个有序链表">3.合并两个有序链表</h4>

<p>将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p>

<p><strong>示例：</strong>
&gt;输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4
&gt;输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</p>

<p><strong>解答：</strong></p>

<pre><code class="language-go">
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func mergeTwoLists(l1 *ListNode, l2 *ListNode) *ListNode {
	if l1 == nil &amp;&amp; l2 == nil {
		return nil
	}
	if l1 == nil {
		return l2
	}
	if l2 == nil {
		return l1
	}
	l := &amp;ListNode{}
	f := l
	for l1 != nil &amp;&amp; l2 != nil {
		if l1.Val &lt; l2.Val {
			l.Next = l1
			l1 = l1.Next
		} else {
			l.Next = l2
			l2 = l2.Next
		}
		l = l.Next
	}
	if l1 != nil {
		l.Next = l1
	}
	if l2 != nil {
		l.Next = l2
	}
	f = f.Next
	return f
}
</code></pre>

<p><strong>知识点：</strong>
技巧是设定一个头结点，后续运算后可直接返回头结点。</p>

<h4 id="4">4.</h4>

<p><strong>示例：</strong>
&gt;</p>

<p><strong>解答：</strong></p>

<pre><code class="language-go">
</code></pre>

<p><strong>知识点：</strong></p>

<h4 id="5">5.</h4>

<p><strong>示例：</strong>
&gt;</p>

<p><strong>解答：</strong></p>

<pre><code class="language-go">
</code></pre>

<p><strong>知识点：</strong></p>
        </div>
      </div>
    </div>
    <div class="footer">
  
  <p>Powered by <a href="http://gohugo.io">Hugo</a>. This theme—Slim—is open sourced on <a href="https://github.com/zhe/hugo-theme-slim">Github</a>.</p>
  
</div>

  </div>
  <script src="http://www.arthur-code-42.cc/js/slim.js"></script>
  

</body>

</html>